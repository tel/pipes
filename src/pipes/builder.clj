(ns pipes.builder
  (:refer-clojure
   :exclude [chunk
             chunk-append 	chunk-buffer
             chunk-cons chunk-first
             chunk-next chunk-rest])
  (:require [clojure.tools.macro :as mt])
  (:use     [pipes.types]
            [pipes.util]
            [slingshot.slingshot :only [throw+ try+]])
  (:import  [pipes.types
             Pipeline
             Source  SourcePipe
             Conduit ConduitPipe
             Sink    SinkPipe]))

(defmacro mksource
  "Macro for easily building Source objects.

   The body of mksource is run when a Source object is prepared and
   must return a (run [continue?] ...) form which defines a function

   run :: Bool -> SourceResult a

   (see pipes.types for more details)

   mksource Sources automatically follow Source invariants: upon
   receiving a closing signal they return an EOF, and, once returned
   the first Failure or EOF, they return EOFs forevermore."
  ([& body]
     `(Source.
       (fn []
         ;; We rewrite the run symbol to be a macro that wraps fn
         (mt/macrolet [(~'run
                        ([args# & body#]
                           (source-protected-run args# body#)))]
           ~@body)))))

(defmacro mkconduit
  "Macro for easily building Conduit objects.

   The body of mkconduit is run when a Conduit object is prepared and
   must return a (run [continue? chunk] ...) form which defines a
   function

   run :: Bool -> [a] -> ConduitResult a

   (see pipes.types for more details)

   mkconduit Conduits automatically follow Conduit invariants: once
   they've received a closing signal, Failed, or returned an EOF, the
   body is ignored and they return EOFs from here on out."
  [& body]
  `(Conduit.
    (fn []
      ;; We rewrite the run symbol to be a macro that wraps fn
      (mt/macrolet [(~'run
                     ([args# & body#]
                        (conduit-protected-run args# body#)))]
        ~@body))))

(defmacro mksink
  "Macro for easily building Sink objects.

   The body of mksink is run when a Sink object is prepared and must
   return a (run [continue? chunk] ...) form which defines a function

   run :: Bool -> [a] -> SinkResult a

   (see pipes.types for more details)

   mksink Sinks automatically enforce and follow Sink invariants: upon
   receiving a close signal they must either Fail or Yield, and once a
   mksink Sink has Failed or Yielded pushed chunks raise errors."
  
  [& body]
  `(Sink.
    (fn []
      ;; We rewrite the run symbol to be a macro that wraps fn
      (mt/macrolet [(~'run
                     ([args# & body#]
                        (sink-protected-run args# body#)))]
        ~@body))))


(defmacro mkpipeline
  "Macro for wrapping Pipelines. Nothing special. Pipelines are really
  just wrapped thunks."
  [& body]
  `(Pipeline.
    (fn []
      ~@body)))

;;; CONVENIENCE MACROS
;;; 

(defmacro prepare-let
  "Binds prepared forms of sources, sinks, and conduits while ensuring
  that errors raised by the sequential preparation steps don't escape
  before closing the previously prepared objects

  A convenience method for preparing multiple sinks, sources, and
  conduits. Always preferred over raw prepares since it wraps an error
  handler."
  [binds & body]
  (let [[[sym form] rest] (split-at 2 binds)]
    (if (and sym form)
      `(let [~sym (prepare ~form)]
         (try+
          ;; Expand the rest of the binding forms
          (prepare-let ~rest ~@body)
          ;; And ensure that upon errors, EOFs are properly passed
          (catch Object o#
            (~sym (eof))
            (throw+))))
      `(do ~@body))))

(defmacro source
  "The primary interface for building Sources, defines a body which is
   run to generate new sourced values. `binds` are a let-form list of
   closed-over variables. The body form is run each time to create a
   new value which must either be generated by (fail-leaving
   ...), (chunk ...), or (eof). The (optional) close form is run if
   the Source is closed or if body-form returned a Failure or EOF.

   Note that close-form is completely stateful and does not need
   return anything."
  [[& binds] body-form & [close-form]]
  `(mksource
    (let [~@binds
          protect# (fn [out#]
                     ~close-form
                     out#)]
      (~'run [continue?#]
        (if continue?#
          (match-source ~body-form out#
            [:error] (protect# out#)
            [:eof]   (protect# out#))
          (protect# (eof)))))))

(defmacro conduit
  "The primary interface for building Conduits, defines a body which
   is run passing new values bound to `continue-var` and `vals-var`
   for the continue signal and the incoming chunk's value
   vector. `binds` are a let-form list of closed-over variables. The
   body form is run each time to create new ConduitResults from the
   vals, so the body must return a new value generated
   by (fail-leaving ...), (chunk ...), (nothing),
   or (eof). The (optional) close form is run if the Conduit is closed
   or if body-form returned Failure or EOF."
  [[continue-var vals-var] [& binds] body-form & [close-form]]
  `(mkconduit
    (let [~@binds
          protect# (fn [cont?# out#]
                     (do (when (not cont?#)
                           ~close-form)
                         out#))]
      (~'run [~continue-var ~vals-var]
        (match-conduit ~body-form out#
          [:error]   (protect# false out#)
          [:eof]     (protect# false out#)
          [:nothing] (protect# ~continue-var out#)
          [:stream]  (protect# ~continue-var out#))))))

(defmacro sink
  "The primary interface for building Sinks, defines a body which is
  run passing new values bound to `continue-var` and `vals-var` for
  the continue signal and the incoming chunk's value vector. `binds`
  are a let-form list of closed-over variables. The body form is run
  each time to create new SinkResults from the incoming vals, so the
  body must return a new value generated by (fail-leaving
  ...), (nothing), or (yield ...). The body MUST return a Failure or
  Yield if `continue-var` is bound to `false`. The (optional) close
  form is run if the Sink is closed or if body-form returns Failure or
  a Yield."
  [[continue-var vals-var] [& binds] body-form & [close-form]]
  `(mksink
    (let [~@binds
          protect# (fn [cont?# out#]
                     (do (when (not cont?#)
                           ~close-form)
                         out#))]
      (~'run [~continue-var ~vals-var]
        (match-sink ~body-form out#
          [:error]   (protect# false out#)
          [:nothing] (protect# ~continue-var out#))))))

(defmacro source1*
  "Similar to `source`, but with a slightly different interface. Here,
  the body returns `nil` on EOF or a single value otherwise."
  [[& binds] body-form & [close-form]]
  `(source [~@binds]
     (let [out# ~body-form]
       (if out#
         (chunk [out#])
         (eof)))))

(defmacro conduit1
  "Similar to `conduit`, but with a slightly different interface. Here,
  single values are passed instead of chunks. Note that if an error
  occurs during a chunk then the whole chunk is discarded."
  [[val-var] [& binds] body-form & [close-form]]
  `(conduit [continue?# vals#] [~@binds
                                ;; These are so that the conduit can
                                ;; return an error later if one occurs
                                ;; mid-chunk
                                is-error# (atom nil)
                                err-remains#  (atom [])]
     (if @is-error#
       (fail-leaving (concat @err-remains# vals#) @is-error#)
       (if continue?#
         (let [do-body# (fn [~val-var]
                          ~body-form)]
           (loop [acc# [] dec# vals#]
             (if (empty? dec#)
               (chunk acc#)
               (let [[head# & tail#] dec#]
                 (match-conduit (do-body# head#) result#
                   ;; On errors we lose the accumulator
                   [:error err# rem#] (do
                                        (swap! is-error# (constantly err#))
                                        (swap! err-remains# (constantly
                                                             (concat rem# tail#)))
                                        (chunk acc#))
                   [:nothing]         (recur acc# tail#)
                   ;; Make sure we flush the buffer if it exists
                   [:eof]             (if (empty? acc#)
                                        (eof)
                                        (chunk acc#))
                   [:stream vals#]    (recur (concat acc# vals#) tail#))))))
         (eof)))
     ~close-form))

(defmacro conduit1*
  "Similar to `conduit1`, but with a slightly different
  interface. Now, the body returns either `nil` if there is no new
  value or said new value if it is ready."
  [[val-var] [& binds] body-form & [close-form]]
  `(conduit [continue?# vals#] [~@binds]
     (let [maybe-result# (filter (comp not nil?)
                                 (for [val# vals#]
                                   (let [~val-var]
                                     ~body-form)))
           result# (if (empty? maybe-result#)
                     (nothing)
                     (chunk maybe-result#))]
       result#)
     ~close-form))

(defmacro sink1
  "Similar to `sink`, but with a slightly different interface. Here,
  single values are passed instead of chunks."
  [[val-var] [& binds] body-form & [close-form]]
  `(sink [continue?# vals#] [~@binds]
     (if continue?#
       (let [do-body# (fn [~val-var]
                        ~body-form)]
         (loop [dec# vals#]
           (if (empty? dec#)
             (nothing)
             (let [[head# & tail#] dec#]
               (match-sink (do-body# head#) result#
                 [:error err# rem#] (fail-leaving (concat rem# tail#) err#)
                 [:nothing]         (recur tail#)
                 [:yield out# rem#] (yield out# (concat rem# tail#)))))))
       (fail-leaving [] {:fatal "Sink1 did not consume enough before EOF."}))
     ~close-form))

(defmacro sink1*
  "Similar to `sink1`, but with a slightly different interface. Now,
  the body form needs only return nil, to represent Nothing, until it
  yields a value."
  [[val-var] [& binds] body-form & [close-form]]
  `(sink [continue?# vals#] [~@binds]
     (if continue?#
       (let [do-body# (fn [~val-var]
                        ~body-form)]
         (loop [dec# vals#]
           (if (empty? dec#)
             (nothing)
             (let [[head# & tail#] dec#
                   out# (do-body# head#)]
               (if out#
                 (yield out# (if (empty? tail#) [] tail#))
                 (recur tail#))))))
       (fail-leaving [] {:fatal "Sink1* did not consume enough before EOF."}))))
